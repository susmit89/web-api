{
	"_id ": "5b21ca3eeb7f6fbccd473688",
	"id": "Monotonic-Stack-5b21ca3eeb7f6fbccd473688",
	"title": "Monotonic Stack",
	"topic": {
		"_id": "5b21ca3eeb7f6fbccd486865",
		"name": "Data Structure"
	},
	"numberInStock": 6,
	"dailyRentalRate": 2.5,
	"publishDate": "2020-01-03T19:04:28.809Z",
	"metadata": ["Stack is one of the popular data structures used in a lot of algorithms like backtracking, depth-for-search(DFS), reverse string, undo/redo, call stack and many more. There are many forms of stacks such as Min Stack - which gives the minimum number in stack in constant time O(1). Max Stack - which gives the maximum number. Other than that there is a monotonic stack. It is called monotonic because the order in the stack is either increasing or decreasing."],
	"content": {
		"rows": 7,
		"coumns": 0,
		"images": {},
		"text": [{
				"row": 0,
				"column": 0,
				"type": "heading",
				"value": ["When to use Stack"]
			},
			{
				"row": 1,
				"column": 0,
				"type": "paragraph",
				"value": ["Stack is mostly used in problem solving where you store partially solved problems(probably because there was interruption and you want to focus on different problems e.g. call stack, you don't have enough input to solve e.g. DFS, or traversing hierarchy e.g navigating folders in file system) only to be solved later in Last in First Order(LIFO)."]
			},
			{
				"row": 2,
				"column": 0,
				"type": "heading",
				"value": ["Intuition for Monotonic Stack"]
			},
			{
				"row": 3,
				"column": 0,
				"type": "image",
				"caption": ["Consider an example where 5 people with different heights are standing in line and one has to tell who is the next tallest person standing on the right side?"],
				"reference": "images/person_height.jpg"
			},
			{
				"row": 4,
				"column": 0,
				"type": "paragraph",
				"value": ["We can solve this problem by considering one person at a time and comparing heights of the person standing next to the right. That means for every person we have traversed once. So two find the answer we traverse n^2. Is there a way we can find out by going through each person once?"]
			},
			{
				"row": 5,
				"column": 0,
				"type": "paragraph",
				"value": ["for current_person_height in heights:\n\tfor person_on_right_height in heights:\n\t\tif current_person_height < person_on_right_height:\n\t\t\tprint(“Tallest person on right height is ”, person_on_right_height)"]
			},
			{
				"row": 6,
				"column": 0,
				"type": "paragraph",
				"value": ["FL enables devices like mobile phones to collaboratively learn a shared prediction model while keeping the training data on the device instead of requiring the data to be uploaded and stored on a central server."]
			},
			{
				"row": 7,
				"column": 0,
				"type": "heading",
				"value": ["How to solve problems usiing Monotonic Stack"]
			},
			{
				"row": 8,
				"column": 0,
				"type": "paragraph",
				"value": ["It works like this: your device downloads the current model, improves it by learning from data on your phone, and then summarizes the changes as a small focused update. Only this update to the model is sent to the cloud, using encrypted communication, where it is immediately averaged with other user updates to improve the shared model. All the training data remains on your device, and no individual updates are stored in the cloud."]
			},
			{
				"row": 9,
				"column": 0,
				"type": "heading",
				"value": ["Where to use Montonic Stack"]
			},
			{
				"row": 10,
				"column": 0,
				"type": "paragraph",
				"value": ["There are a number of core challenges associated with FL. First, communication is a critical bottleneck in FL networks where data generated on each device remain local. In order to train a model using data generated by the devices in the network, it is necessary to develop communication-efficient methods that reduce the total number of communication rounds, and also iteratively send small model updates as part of the training process, as opposed to sending the entire data set."]
			}
		]
	}
}
