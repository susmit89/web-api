{
	"_id ": "5b21ca3eeb7f6fbccd473688",
	"id": "Monotonic-Stack-5b21ca3eeb7f6fbccd473688",
	"title": "Monotonic Stack",
	"topic": {
		"_id": "5b21ca3eeb7f6fbccd486865",
		"name": "Data Structure"
	},
	"numberInStock": 6,
	"dailyRentalRate": 2.5,
	"publishDate": "2020-01-03T19:04:28.809Z",
	"metadata": ["Stack is one of the popular data structures used in a lot of algorithms like backtracking, depth-for-search(DFS), reverse string, undo/redo, call stack and many more. There are many forms of stacks such as Min Stack - which gives the minimum number in stack in constant time O(1). Max Stack - which gives the maximum number. Other than that there is a monotonic stack. It is called monotonic because the order in the stack is either increasing or decreasing."],
	"content": {
		"rows": 7,
		"coumns": 0,
		"images": {},
		"text": [{
				"row": 0,
				"column": 0,
				"type": "heading",
				"value": ["When to use Stack"]
			},
			{
				"row": 1,
				"column": 0,
				"type": "paragraph",
				"value": ["Stack is mostly used in problem solving where you store partially solved problems(probably because there was interruption and you want to focus on different problems e.g. call stack, you don't have enough input to solve e.g. DFS, or traversing hierarchy e.g navigating folders in file system) only to be solved later in Last in First Order(LIFO)."]
			},
			{
				"row": 2,
				"column": 0,
				"type": "heading",
				"value": ["Intuition for Monotonic Stack"]
			},
			{
				"row": 3,
				"column": 0,
				"type": "image",
				"caption": ["Consider an example where 5 people with different heights are standing in line and one has to tell who is the next tallest person standing on the right side?"],
				"reference": "images/person_height.jpg"
			},
			{
				"row": 4,
				"column": 0,
				"type": "paragraph",
				"value": ["We can solve this problem by considering one person at a time and comparing heights of the person standing next to the right. That means for every person we have traversed once. So two find the answer we traverse n^2. Is there a way we can find out by going through each person once?"]
			},
			{
				"row": 5,
				"column": 0,
				"type": "code",
				"value": ["for current_person_height in heights:\n \t for person_on_right_height in heights:\n\t\tif current_person_height < person_on_right_height:\n\t\t\tprint(“Tallest person on right height is ”, person_on_right_height)"]
			},
			{
				"row": 6,
				"column": 0,
				"type": "paragraph",
				"value": ["That's where the monotonic stack comes in. We are going to store the height of the current person in the stack and move to the next. We compare the current person's height with the height of the person at the top of the stack. If we found the current person is taller than the person in the stack we pop that person from the stack. We found the taller person of the person we put in the stack. If the stack is still not empty we do the same comparison until the stack is empty or the current person is shorter. We use a loop for this operation. At the end of the loop we add the current person to stack. This way we traverse the list only once."]
			},
			{
				"row": 7,
				"column": 0,
				"type": "code",
				"value": ["height=[9,6,10,7,9]\nstack = [] #initialize stack\nresult = [0,0,0,0,0] #initialize array to store positon of taller person on right\nstack.append(0) #add person standing at 0 position\nfor current in range(1, len(height)): #iterate through from second person till last\n\twhile stack and height[stack[-1]] < height[current]: #compare current person height with the height of the person at the top of the stack\n\t\t#current person is taller person for the person at top of stack\n\t\tresult[stack.pop()] = current\n\t stack.append(current)\nprint(result) #[2, 2, 0, 4, 0], No person iis taller for 3rd person and there is no right for 5th person"]
			},
			{
				"row": 8,
				"column": 0,
				"type": "paragraph",
				"value": ["It works like this: your device downloads the current model, improves it by learning from data on your phone, and then summarizes the changes as a small focused update. Only this update to the model is sent to the cloud, using encrypted communication, where it is immediately averaged with other user updates to improve the shared model. All the training data remains on your device, and no individual updates are stored in the cloud."]
			},
			{
				"row": 9,
				"column": 0,
				"type": "heading",
				"value": ["Where to use Montonic Stack"]
			},
			{
				"row": 10,
				"column": 0,
				"type": "paragraph",
				"value": ["There are a number of core challenges associated with FL. First, communication is a critical bottleneck in FL networks where data generated on each device remain local. In order to train a model using data generated by the devices in the network, it is necessary to develop communication-efficient methods that reduce the total number of communication rounds, and also iteratively send small model updates as part of the training process, as opposed to sending the entire data set."]
			}
		]
	}
}
