{
	"_id ": "5b21ca3eeb7f6fbcdd479062",
	"id": "Depth-First-Search-and-How-to-solve-examples-based-on-DFS-5b21ca3eeb7f6fbcdd479062",
	"title": "Depth First Search and How to solve examples based on DFS",
	"topic": {
		"_id": "5b21ca3eeb7f6fbccd486412",
		"name": "Algorithms"
	},
	"keywords": ["Graph Search", "Depth First Search", "Stack", "Path Finding"],
	"dailyRentalRate": 2.5,
	"publishDate": "2021-07-12T19:04:28.809Z",
	"metadata": ["Depth First Search (DFS) is a search algorithm mostly used in graphs and binary tree data structures. It is useful to solve cycle detection in the graph, topological sort, and pathfinding problems. DFS can be implemented in a recursive and nonrecursive fashion using a stack."],
	"content": {
		"rows": 7,
		"coumns": 0,
		"images": {},
		"text": [{
				"row": 0,
				"column": 0,
				"type": "heading",
				"value": ["How DFS Works?"]
			},
			{
				"row": 1,
				"column": 0,
				"type": "list",
				"value": ["In a given graph or tree, DFS starts at the root or start node. It explores the node by expanding its children.", "It visits the first child node and expands and explores its children. It will keep exploring until it reaches the last leaf node.", "After it has explored a tree under the first child then it explores its sibling nodes.", "The algorithm ends when all trees under all siblings", "The algorithm can also terminate early if we found goal node", "For Example, In the graph below we start at 0 then expand children 1,2, and 3. We first visit child 1 first and expand the tree under it.  We see it has children 4 and 5. We visit 4 first. Since 4 doesn’t have any children we visit its sibling 5. Since 5 doesn't have any children and parent of 5 i.e 1 don't have any more children we move to visit its sibling 2. We explore 2 children which is 6 only. Since 2 don’t have any more children we move to 3. 3 has 7 as a child we explore that. Now since 7 don't have children we move back to parent 3. Also all of 1 sibling we already explored we move back to 1. The algorithm terminates here. So the path we traverse is 0->1->5->4->2->6->3->7"]
			},
			{
				"row": 2,
				"column": 0,
				"type": "image",
				"caption": ["DFS Graph Search"],
				"reference": "images/DFS-graph-search-5b21ca3eeb7f6fbcdd479062.jpg"
			},
			{
				"row": 3,
				"column": 0,
				"type": "paragraph",
				"value": [""]
			},
			{
				"row": 4,
				"column": 0,
				"type": "paragraph",
				"value": [""]
			},
			{
				"row": 5,
				"column": 0,
				"type": "heading",
				"value": ["How to use bloom filters"]
			},
			{
				"row": 6,
				"column": 0,
				"type": "paragraph",
				"value": [""]
			},
			{
				"row": 7,
				"column": 0,
				"type": "heading",
				"value": ["Where is bloom filters used"]
			},
			{
				"row": 8,
				"column": 0,
				"type": "paragraph",
				"value": [""]
			},
			{
				"row": 9,
				"column": 0,
				"type": "heading",
				"value": [""]
			},
			{
				"row": 10,
				"column": 0,
				"type": "paragraph",
				"value": [""]
			},
			{
				"row": 11,
				"column": 0,
				"type": "heading",
				"value": ["When using source or target or combined data"]
			},
			{
				"row": 12,
				"column": 0,
				"type": "paragraph",
				"value": [""]
			},
			{
				"row": 13,
				"column": 0,
				"type": "paragraph",
				"value": [""]
			},
			{
				"row": 14,
				"column": 0,
				"type": "heading",
				"value": ["References"]
			},
			{
				"row": 15,
				"column": 0,
				"type": "references",
				"value": [{
					"authors": "Xingyi Yang∗, Xuehai He∗,Yuxiao Liang, Yue Yang",
					"title": "Transfer Learning or Self-supervised Learning? A Tale of Two Pretraining Paradigms"
				}]
			}
		]
	}
}
