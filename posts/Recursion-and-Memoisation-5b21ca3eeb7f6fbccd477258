{
	"_id ": "5b21ca3eeb7f6fbccd477258",
	"id": "Recursion-and-Memoisation-5b21ca3eeb7f6fbccd477258",
	"title": "Recursion and Memoisation",
	"topic": {
		"_id": "5b21ca3eeb7f6fbccd486412",
		"name": "Algorithms"
	},
	"numberInStock": 6,
	"dailyRentalRate": 2.5,
	"publishDate": "2021-06-18T19:04:28.809Z",
	"metadata": ["The recursive call to a function is one of the methods to solve a problem that is made of many sub-problems. In recursion, the main idea is to find a base sub-problem and use it recursively. E.g Find factorial of 6.  We calculate 6! by multiplying 6 with 5!. Calculate 5! by multiplying 5 with 4!. So recursively we can solve factorial of n by calculating n * func(n-1). But while running this program the computer still needs to calculate every factorial. To calculate 6! it will still need to calculate 4! even though we already calculated 4! while calculating 5!. This is time-consuming so we use small memory to store previous calculations. Before doing new calculations first we check if the calculation is already in memory. If it is not, we calculate the result from memory. This is called Memoization. This method is pretty popular for solving Dynamic Programming and Backtracking Problems."],
	"content": {
		"rows": 7,
		"coumns": 0,
		"images": {},
		"text": [{
				"row": 0,
				"column": 0,
				"type": "heading",
				"value": ["Fibonacci Series with Recursion and Memoisation"]
			},
			{
				"row": 1,
				"column": 0,
				"type": "paragraph",
				"value": ["The Fibonacci Series is a classic problem in programming. It can be solved using recursion and memoization. Following is the python code to solve Fibonacci Series for n using recursion and memoization."]
			},
			{
				"row": 2,
				"column": 0,
				"type": "code",
				"value": ["#Fibonnaci Series with recursion\ndef fib(n):\n    if n==0:\n        return 0\n    if n == 1: \n        return 1\n    return fib(n-1) + fib(n-2)\n\nn=6\nwhile n:\n    print(fib(n)) #print sequence 1,1,2,3,5,8\n    n-=1"]
			},
			{
				"row": 3,
				"column": 0,
				"type": "code",
				"value": ["def fib(n, memo): #with Memo and recursion\n    if n==0:\n        return 0\n    if n == 1: \n        return 1\n    if n not in memo:  #if n is already solved return solved value else calculate and add to memo\n        memo[n] = fib(n-1, memo) + fib(n-2, memo)\n    return memo[n]\nn=6\nmemo={}\nwhile n:\n    print(fib(n,memo)) #print sequence 1,1,2,3,5,8\n    n-=1"]
			},
			{
				"row": 4,
				"column": 0,
				"type": "heading",
				"value": ["Recursion, implicit memory and Iteration"]
			},
			{
				"row": 5,
				"column": 0,
				"type": "paragraph",
				"value": ["In the above both codes we use recursion. In the first code, it seems we donâ€™t require extra memory. But that is not true. The computer requires to store partial results in the stack before calculating sub-problems. After calculation, it pops out partial results from the stack and computes results. For Eg for n = 3, the computer pushes fib(3), then it pushes fib(2) and calculates fib(1) which is 1. Then it pops fib(2) from the stack and calculates. Finally, pop fib(3), calculate, and return the result. It does the same even if we use memoization. It is not space-efficient that is why we use iteration. All the recursion problems can be solved as iteration problems. It might get complicated but could be more efficient than recursion. Following is the iteration of the same Fibonacci Series"]
			},
			{
				"row": 6,
				"column": 0,
				"type": "code",
				"value": ["def fib(n, memo): #with Memo and iteration\n    if n==0:\n        return 0\n    memo[0]=0 #base cases\n    memo[1]=1\n    i=2\n    while i<=n:\n        if i not in memo:  \n            memo[i] = memo[i-1] + memo[i-2]\n        i+=1\n        \n    return memo[n]\nn=6\nmemo={}\nwhile n:\n    print(fib(n,memo)) #print sequence 1,1,2,3,5,8\n    n-=1"]
			},
			{
				"row": 7,
				"column": 0,
				"type": "heading",
				"value": [""]
			},
			{
				"row": 8,
				"column": 0,
				"type": "paragraph",
				"value": [""]
			},
			{
				"row": 9,
				"column": 0,
				"type": "heading",
				"value": [""]
			},
			{
				"row": 10,
				"column": 0,
				"type": "paragraph",
				"value": [""]
			},
			{
				"row": 11,
				"column": 0,
				"type": "heading",
				"value": [""]
			},
			{
				"row": 12,
				"column": 0,
				"type": "paragraph",
				"value": [""]
			},
			{
				"row": 13,
				"column": 0,
				"type": "paragraph",
				"value": [""]
			},
			{
				"row": 14,
				"column": 0,
				"type": "heading",
				"value": ["References"]
			}


		]
	}
}
