{
	"_id ": "5b21ca3eeb7f6fbcdd479019",
	"id": "Path-Finding-problems-using-Depth-First-Search-DFS-5b21ca3eeb7f6fbcdd479019",
	"title": "Path Finding problems using Depth-First-Search DFS",
	"topic": {
		"_id": "5b21ca3eeb7f6fbccd486412",
	    "name": "Algorithms"
	},
	"keywords": ["Graph Search", "Depth First Search", "Stack", "Path Finding"],
	"dailyRentalRate": 2.5,
	"publishDate": "2021-07-12T19:04:28.809Z",
	"metadata": ["Pathfinding problems have many applications, from computer games, network routing to AI robots. If we want to explore unknown graphs and want to gather more information, DFS is a good choice. DFS is the most simple path exploration of all algorithms. It is appropriate to use during space restriction in complex state representation and acyclic graphs."],
	"content": {
		"rows": 7,
		"coumns": 0,
		"images": {},
		"text": [{
				"row": 0,
				"column": 0,
				"type": "heading",
				"value": ["All Paths From Source to Target"]
			},
			{
				"row": 1,
				"column": 0,
				"type": "link",
				"title": ["797. All Paths From Source to Target"],
				"link": "https://leetcode.com/problems/all-paths-from-source-to-target/"
			},
			{
				"row": 2,
				"column": 0,
				"type": "paragraph",
				"value": ["Given a directed acyclic graph (DAG) of n nodes labeled from 0 to n - 1, find all possible paths from node 0 to node n - 1, and return them in any order. The graph is given as follows: graph[i] is a list of all nodes you can visit from node i (i.e., there is a directed edge from node i to node graph[i][j])."]
			},
			{
				"row": 3,
				"column": 0,
				"type": "image",
				"caption": ["Input: graph = [[1,2],[3],[3],[]]"],
				"reference": "images/all_1-5b21ca3eeb7f6fbcdd479019.jpg"
			},
			{
				"row": 4,
				"column": 0,
				"type": "subheading",
				"value": ["Intuition"]
			},
			{
				"row": 5,
				"column": 0,
				"type": "list",
				"value": ["In the above example, we need to find all paths from 0 node to n-1 node.","We will use recursive DFS.","Initialize the visited list to store visited nodes so we don't visit the same node twice.","Initialize the result list to store paths.","We follow 3 steps: mark node visited, check if the node is the destination, and explore its unvisited neighbors.","Our DFS algorithm will first start at node 0 and the destination is 3.","Below is the python code"]
			},
			{
				"row": 6,
				"column": 0,
				"type": "code",
				"value": ["\ndef allPathsSourceTarget(graph):\n    def dfs(visited, vertex, destination):\n        visited.append(vertex) #Mark node visted\n        if destination == vertex: #check if we reached destination \n                \n            res.append(visited[:]) #copy nodes from visited to result\n            \n        for u in graph[vertex]: \n            if u not in visited: #explore its unvisited neighbours\n                dfs(visited, u, destination)\n        visited.remove(vertex) \n    visited = [] # to store visited node\n    res = [] # to store the result\n    dfs(visited, 0, len(graph)-1)\n    return res #res = [[0,1,3],[0,2,3]]"]
			},
			{
				"row": 7,
				"column": 0,
				"type": "heading",
				"value": ["Path with Maximum Gold"]
			},
			{
				"row": 8,
				"column": 0,
				"type": "link",
				"title": ["1219. Path with Maximum Gold"],
				"link": "https://leetcode.com/problems/path-with-maximum-gold/"
			},
			{
				"row": 9,
				"column": 0,
				"type": "paragraph",
				"value": ["In a gold mine grid of size m x n, each cell in this mine has an integer representing the amount of gold in that cell, 0 if it is empty.","Return the maximum amount of gold you can collect under the conditions:"]
			},
			{
				"row": 10,
				"column": 0,
				"type": "code",
				"value": ["\nInput: grid = [[0,6,0],[5,8,7],[0,9,0]]\nOutput: 24\nExplanation:\n[[0,6,0],\n [5,8,7],\n [0,9,0]]\nPath to get the maximum gold, 9 -> 8 -> 7.\n"]
			},
			{
				"row": 11,
				"column": 0,
				"type": "heading",
				"value": ["When using source or target or combined data"]
			},
			{
				"row": 12,
				"column": 0,
				"type": "paragraph",
				"value": [""]
			},
			{
				"row": 13,
				"column": 0,
				"type": "paragraph",
				"value": [""]
			},
			{
				"row": 14,
				"column": 0,
				"type": "heading",
				"value": ["References"]
			},
			{
				"row": 15,
				"column": 0,
				"type": "references",
				"value": [{
					"authors": "Xingyi Yang∗, Xuehai He∗,Yuxiao Liang, Yue Yang",
					"title": "Transfer Learning or Self-supervised Learning? A Tale of Two Pretraining Paradigms"
				}]
			}
		]
	}
}
